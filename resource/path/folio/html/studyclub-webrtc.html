<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <link rel="stylesheet" href="profile.css">
    <script type="module" src="profile.js"></script>
    <title>profile</title>
</head>
<body>
    <div class="frame">
        <div class="blind">
            <div class="profile-box">
                <div class="top">
                    <div class="content">
                        <div class="blockquote" style="margin-top: 100px; margin-bottom: 100px;">
                            <p>í”„ë¡œì íŠ¸ì˜ ê°„ë‹¨í•œ ì†Œê°œ, ì´ë¯¸ì§€ ì‚´í´ë³´ê¸°, í•µì‹¬ êµ¬ì¡°, ê°„ëµí•œ ì½”ë“œ ì–¸ê¸‰ ìˆœìœ¼ë¡œ ì§„í–‰ ë©ë‹ˆë‹¤.</p>
                            <p>í˜„ì¬ í˜ì´ì§€ëŠ” íŒ€ í”„ë¡œì íŠ¸ StudyClubë° </p>
                            <p>ë‹´ë‹¹ê¸°ëŠ¥ WebRTC, Signaling Server, Client ë””í…Œì¼ ë·° ì…ë‹ˆë‹¤.</p>
                            <p style="font-size: 1.8em; font-style: normal;">ğŸ˜Š</p>
                        </div>

                        <h1>ê°œìš”</h1>
                        <h2>í”„ë¡œì íŠ¸ ì†Œê°œ</h2>
                        <h3>StudyClub</h3>
                        <div class="thing">
                            <p>íŒ€ìœ¼ë¡œì„œ ì§„í–‰ëœ í”„ë¡œì íŠ¸ì…ë‹ˆë‹¤.
                                <br>ìŠ¤í„°ë”” ì‚¬ìš©ìë“¤ì„ ëª¨ì§‘í•˜ê³  ë‹¤ë¥¸ ì„œë¹„ìŠ¤ë¥¼ ì´ìš©í•˜ëŸ¬ ê°€ëŠ” ê²ƒì´ ì•„ë‹Œ, 
                                <br>í˜„ ì„œë¹„ìŠ¤ ë‚´ì—ì„œ ì‚¬ìš©ì ëª¨ì§‘ ë° ê¸°ëŠ¥ì„± ì»¤ë®¤ë‹ˆí‹°ë¥¼ í•˜ë‚˜ì˜ ì–´í”Œë¦¬ì¼€ì´ì…˜ìœ¼ë¡œ í™•ì¥í•˜ê³  ì‹¶ì—ˆìŠµë‹ˆë‹¤.
                            </p>
                        </div>

                        <h3>WebRTC</h3>
                        <div class="thing">
                            <p>WebRTCë¼ëŠ” ê¸°ìˆ ì´ í¥ë¯¸ë¡œì›Œ íŒ€ í”„ë¡œì íŠ¸ë¡œ í•©ë¥˜í•˜ì˜€ìŠµë‹ˆë‹¤.
                                <br>Webì—ì„œ N:N ë‹¤ìˆ˜ì˜ ì‚¬ìš©ìë“¤ê³¼ í™”ìƒ í†µí™”ë¥¼ ì§„í–‰í•˜ê±°ë‚˜,
                                <br>ì—°ê²°ëœ P2P ë°ì´í„° ì±„ë„ì„ í†µí•´ ë°ì´í„°ë¥¼ êµí™˜í•˜ì—¬ ì±„íŒ… ë° ê³µìš© ë³´ë“œì˜ ë‚™ì„œë‚˜ ì‚¬ì§„ì„ ë™ê¸°í™”í•©ë‹ˆë‹¤.
                                <br>WebRTC ì—°ê²° ê³¼ì •ì„ NodeJs, Socketì´ ì•„ë‹Œ Http ë©”ì‹œì§€ë¡œ í•¸ë“¤ë§í•˜ê³  ì‹¶ì—ˆìœ¼ë©°,
                                <br>ì´ë²¤íŠ¸ ì§€í–¥ì„±ìœ¼ë¡œ í™•ì¥ì„±ì„ ê³ ë ¤í•˜ì—¬ ì‹œê·¸ë„ë§ ì„œë²„ ë° í´ë¼ì´ì–¸ë¥¼ ë§¡ì•˜ìŠµë‹ˆë‹¤.
                            </p>
                        </div>

                        <h2>ì‚¬ìš©ê¸°ìˆ </h2>
                        <p>
                            <img src="https://img.shields.io/badge/java-007396?style=for-the-badge&logo=java&logoColor=white">
                        </p>
                        <p>
                            <img src="https://img.shields.io/badge/javascript-F7DF1E?style=for-the-badge&logo=javascript&logoColor=black">
                        </p>
                        </p>
                        <p>
                            <img src="https://img.shields.io/badge/spring-6DB33F?style=for-the-badge&logo=spring&logoColor=white">
                        </p>

                        <h3>ë¼ì´ë¸ŒëŸ¬ë¦¬</h3>
                        <p>
                            <img src="https://img.shields.io/badge/WebRTC-4FC08D?style=for-the-badge&logo=webrtc&logoColor=white">
                        </p>
                    
                        <h1>ì‚´í´ë³´ê¸°</h1>
                        <h2>ì´ë¯¸ì§€</h2>
                        <div class="slider-box"></div>  

                        <h2>êµ¬í˜„ê¸°ëŠ¥</h2>
                        <h3>StudyClub</h3>
                        <p>íšŒì›ê°€ì…, ë¡œê·¸ì¸</p>
                        <p>ê²Œì‹œíŒ CRUD</p>
                        <p>ì½”ë©˜íŠ¸ ì‘ì„±</p>
                        <p>Oauth</p>
                        <p>WebRTC 1:1</p>

                        <h3>WebRTC</h3>
                        <p>WebRTC N:N</p>
                        <p>ê³µìš© ë³´ë“œ</p>
                        <p>ì±„íŒ…</p>

                        <h2>ë§í¬</h2>
                        <h3>GitHub</h3>
                        <p>
                            <a target="_blank" href="https://github.com/gtypeid/study-club-webrtc.git">
                                <img src="https://img.shields.io/badge/github-181717?style=for-the-badge&logo=github&logoColor=white">
                            </a>
                        </p>
                        <h3>ë°œí‘œ PPT</h3>
                        <p>
                            <a target="_blank" href="https://docs.google.com/presentation/d/1X8NiNeOPEBSMGp2JbWUztfjYr_Dzy9Wv/edit?usp=sharing&ouid=109390394369097049050&rtpof=true&sd=true">
                                <img src="https://img.shields.io/badge/GoogleSlider-F80000?style=for-the-badge&logo=slides&logoColor=white">
                            </a>
                        </p>
<!-- WebRTC -->
                        <h1>WebRTC</h1>
                        <h2>ë‹¤ì´ì–´ê·¸ë¨</h2>
                        <h3>í”„ë¡œì„¸ìŠ¤ í”Œë¡œìš°</h3>
                        <div class="thing">
                            <p>1. ë°œì‹ ìê°€ Offer ìƒì„± ë° ë¡œì»¬ ì •ë³´ ì„¤ì • ì‹œ ë°œì‹ ìì˜ ë„¤íŠ¸ì›Œí¬ í›„ë³´ë“¤ì´ SDPì¸ì¦ì„œì— ë“±ë¡ë©ë‹ˆë‹¤.</p>
                            <p>2. ìˆ˜ì‹ ìëŠ” ë°œì‹ ìì˜ Offerë¥¼ ìˆ˜ì‹ í•˜ê³ , ì›ê²© ì •ë³´ ì„¤ì • ì´í›„ Offerê¸°ë°˜ Answerì‘ë‹µì„ ìƒì„±í•©ë‹ˆë‹¤.</p>
                            <p>3. ì´í›„ ìˆ˜ì‹ ìëŠ” ë§ˆì°¬ê°€ì§€ë¡œ ë¡œì»¬ ì •ë³´ ì„¤ì • ì‹œ ìˆ˜ì‹ ìì˜ ë„¤íŠ¸ì›Œí¬ í›„ë³´ë“¤ì´ SDPì¸ì¦ì„œì— ë“±ë¡ë˜ë©°,</p>
                            <p>4. ì´í•˜ ë°œì‹ ìê°€ SDP ì¸ì¦ì„œê°€ ë‹´ê¸´ Answerë¥¼ ì‘ë‹µë°›ê³  ì›ê²© ì •ë³´ ì„¤ì • ì‹œ,</p>
                            <p>5. ë‘˜ì€ Connected ìƒíƒœë¡œ ì „í™˜ ë˜ë©°, P2P ì—°ê²° ìƒíƒœê°€ ë©ë‹ˆë‹¤.</p>
                        </div>
                        <div class="gram">
                            flowchart LR
                            A[ë°œì‹ ì] -->|"Offer
                            LocalDescription,
                            Icecandidate (SDP)"| B[ìˆ˜ì‹ ì]
                            
                            B[ìˆ˜ì‹ ì] --> |"RemoteDescription,
                            Answer,
                            LocalDescription,
                            Icecandidate (SDP)"| C[ë°œì‹ ì]
                            
                            C[ë°œì‹ ì] --> |"RemoteDescription"| D[ì—°ê²°]
                        </div>
<!-- WebRTC END -->
<!-- Signaling Server -->
                        <h1>Signaling Server</h1>
                        <h2>ë‹¤ì´ì–´ê·¸ë¨</h2>
                        <h3>í”„ë¡œì„¸ìŠ¤ í”Œë¡œìš°</h3>
                        <div class="thing">
                            <p>1. í´ë¼ì´ì–¸íŠ¸ëŠ” ì‹œê·¸ë„ë§ ì„œë²„ì˜ APIë¥¼ í†µí•´ ë°©ì„ ìƒì„±í•˜ê±°ë‚˜, ì ‘ì†í•  ìˆ˜ ìˆìŠµë‹ˆë‹¤.</p>
                            <p>2. ë°©ì— ê´€í•œ ì •ë³´ë¥¼ ìˆ˜ì‹ ë°›ìŒê³¼ ë™ì‹œì— í´ë¼ì´ì–¸íŠ¸ëŠ” ì„œë²„ì˜ SSEEventì— Bindí•˜ì—¬ EventStreamì„ í™œì„±í™”í•˜ê²Œ ë˜ëŠ”ë°,</p>
                            <p>3. ì´í›„ í´ë¼ì´ì–¸íŠ¸ëŠ” ì´ë²¤íŠ¸ë¥¼ ë°œ ìˆ˜ì‹  í•˜ê²Œ ë©ë‹ˆë‹¤.</p>
                            <p>4. ì„œë²„ëŠ” ì´ë²¤íŠ¸ë“¤ì„ ìˆ˜ì‹ í•˜ì—¬ EventStreamìœ¼ë¡œ ì „ë‹¬í•©ë‹ˆë‹¤. </p>
                            <p>5. Streamë‚´ì˜ Eventë“¤ì€ ê°ê°ì˜ EventCaptureê°€ ì²˜ë¦¬í•œ ê²°ê³¼ë¥¼ í´ë¼ì´ì–¸íŠ¸ë“¤ì—ê²Œ ì „ë‹¬í•©ë‹ˆë‹¤.</p>
                        </div>
                        <div class="gram">
                            flowchart LR
                            A[Client] -->|"API
                            /create-room
                            /join-room/{room-id}"| B[Server]
                            B[Server] --> |"RoomInfoProfile"| C[Client]
                            C[Client] -->|SSEEventBind| D[EventStream]
                            
                            A1[Client] --> |"Event
                            Join, Offer, Answer"| B1[Server]
                            B1[Server] -->|Handler| C1[SSEService]
                            C1[SSEService] --> |EventStream| D1[EventCapture]
                            D1[EventCapture] --> E1[Clients]
                            D1[EventCapture] --> E1[Clients]
                            D1[EventCapture] --> E1[Clients]
                        </div>
                        <h2>SSEService</h2>
                        <div class="blockquote">
                            <p>SSEControllerë¥¼ í†µí•´ í´ë¼ì´ì–¸íŠ¸ì— SSEEvent ìŠ¤íŠ¸ë¦¼ì„ ë“±ë¡í•©ë‹ˆë‹¤.
                                <br>EventCaptureë¥¼ í†µí•œ ê²°ê³¼ë¥¼ ì„œë²„ì—ì„œ í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ë©”ì‹œì§€ë¥¼ ë°œì†¡í•  ìˆ˜ ìˆê²Œ ë©ë‹ˆë‹¤.
                            </p>
                        </div>

                        <h3>autowire</h3>
                        <div class="post-root">
                            <article class="post-content">
                                <div class="folded-corner">
                                    <p>
                                        EventCapture êµ¬í˜„ì²´ë“¤ì„ ì˜ì¡´ ì£¼ì…í•©ë‹ˆë‹¤.
                                    </p>
                                </div>
                                <div class="thing">
                                    <p>
                                        OfferEventêµ¬í˜„ì²´ëŠ” Offer, AnswerEventêµ¬í˜„ì²´ëŠ” Answer.
                                        <br>ì´ë²¤íŠ¸ì™€ ë§¤ì¹­ ë©ë‹ˆë‹¤. ì‚¬ìš©ìì— ì˜ê±° EventCapture í´ë˜ìŠ¤ê°€ í™•ì¥ ë˜ì–´ë„,
                                        <br>ê¸°ì¡´ ì½”ë“œë¥¼ ìˆ˜ì • í•˜ì§€ ì•Šë„ë¡ Spring ì˜ì¡´ ì£¼ì…ì„ í™œìš©í•´ ë³´ì•˜ìŠµë‹ˆë‹¤.
                                    </p>
                                </div>
                                <pre class="prettyprint">
                                    <br>
            @Service
            public class SSEService {

                private Map< String, Map< String, SseEmitter > > roomClientEmitters 
                    = new ConcurrentHashMap<>();
                private Map< String, EventCapture > eventCaptureStore 
                    = new ConcurrentHashMap<>();

                @Autowired
                SSEService(List< EventCapture > eventCaptures){
                    eventCaptures.forEach(ec -> eventCaptureStore.put(getEventType(ec), ec));
                }

                private String getEventType(EventCapture eventCapture){
                    String simpleName = eventCapture.getClass().getSimpleName().toLowerCase();
                    int index = simpleName.indexOf("event");
                    return simpleName.substring(0, index);
                }
            }
                                </pre>
                                <pre class="prettyprint">
                                    <br>
            @Component
            public class OfferEvent implements EventCapture{
                .
                .
                .
            }

            @Component
            public class AnswerEvent implements EventCapture{
                .
                .
                .
            }
                                </pre>
                            </article>
                        </div>
                        <h3>publish</h3>
                        <div class="post-root">
                            <article class="post-content">
                                <div class="folded-corner">
                                    <p>
                                        í´ë¼ì´ì–¸íŠ¸ë¡œë¶€í„° ìš”ì²­ë°›ì€ HandleEventë¥¼ ë°œí–‰í•©ë‹ˆë‹¤.
                                        <br>í´ë¼ì´ì–¸íŠ¸ë“¤ì„ ìˆœíšŒ í•˜ë©°, EventCaptureê°€ ì í•©í•œ Eventë¥¼ ì²˜ë¦¬í•˜ì—¬,
                                        <br>í´ë¼ì´ì–¸íŠ¸ë“¤ì—ê²Œ ì „ë‹¬í•©ë‹ˆë‹¤.
                                    </p>
                                </div>
                                <div class="thing">
                                    <p>
                                        ì±…ì„ ë° ì²˜ë¦¬ë¥¼ EventCaptureë¡œ ìœ„ì„ì‹œì¼œ,
                                        <br>ì´ë²¤íŠ¸ í™•ì¥ì—ë„ ì½”ë“œ ìˆ˜ì •ì´ ì—†ë„ë¡ ë””ìì¸í•´ë³´ì•˜ìŠµë‹ˆë‹¤.
                                    </p>
                                </div>
                                <pre class="prettyprint">
                                    <br>
            public void publish(HandleEvent handleEvent){
                .
                .
                Map<String, SseEmitter> clients = roomClientEmitters.get(roomUuid);
                clients.forEach( (targetClient, emitter) ->{
                    doPublish(targetClient, handleEvent, emitter, clients);
                });
            }
        
            private void doPublish(String targetClient, HandleEvent handleEvent, 
                SseEmitter emitter, Map< String, SseEmitter > clients){

                String eventType = handleEvent.getEventType();
        
                if( eventCaptureStore.containsKey(eventType) ){
                    EventCapture eventCapture = eventCaptureStore.get(eventType);
                    eventCapture.doAction(targetClient, handleEvent, (data) ->{
                        try {
                            emitter.send(data, MediaType.APPLICATION_JSON);
                        } catch (IOException e) {
                            .
                            .
                        }
                    });
                }
            }
                            </article>
                        </div>
                        <h2>EventCapture</h2>
                        <div class="blockquote">
                            <p>Eventë¥¼ ì í•©í•˜ê²Œ ì²˜ë¦¬í•  ì¸í„°í˜ì´ìŠ¤ì…ë‹ˆë‹¤.
                                <br>ì í•© êµ¬í˜„ì²´ê°€ ê·¸ ì—­í• ì„ êµ¬í˜„í•©ë‹ˆë‹¤.
                            </p>
                        </div>

                        <h3>JoinEvent</h3>
                        <div class="post-root">
                            <article class="post-content">
                                <div class="folded-corner">
                                    <p>
                                        EventCapture êµ¬í˜„í•œ JoinEventì…ë‹ˆë‹¤.
                                        <br>Join ë°œìƒ ì‹œ ìš”ì²­ í´ë¼ì´ì–¸íŠ¸ë¥¼ ì œì™¸í•œ ëª¨ë“  í´ë¼ì´ì–¸íŠ¸ì—ê²Œ ë©”ì‹œì§€ë¥¼ ë°œì†¡í•©ë‹ˆë‹¤.
                                    </p>
                                </div>
                                <pre class="prettyprint">
                                    <br>
            @Component
            public class JoinEvent implements EventCapture{
            
                private final RoomService roomService;
            
                @Autowired
                public JoinEvent(RoomService roomService){
                    this.roomService = roomService;
                }
            
                @Override
                public void doAction(String targetClient, HandleEvent handleEvent, 
                    Consumer< RoomStateEventHandler > consumer) {
            
                    if(!targetClient.equals(handleEvent.getClientUuid())){

                        HandleEvent data = new HandleEvent(handleEvent);
                        Room room = 
                            roomService.getRoomStore().get( handleEvent.getRoomUuid() );
            
                        RoomStateEventHandler roomStateEventHandler = 
                            new RoomStateEventHandler(room, data);
                        consumer.accept(roomStateEventHandler);
                    }
                }
            }
                                </pre>
                            </article>
                        </div>
<!-- Signaling Server END -->
<!-- WebRTC Client -->
                        <h1>WebRTC Client</h1>
                        <h2>ë‹¤ì´ì–´ê·¸ë¨</h2>
                        <h3>í”„ë¡œì„¸ìŠ¤ í”Œë¡œìš°</h3>
                        <div class="thing">
                            <p>1. ì„œë²„ë¡œë¶€í„° Eventë¥¼ ë°›ìœ¼ë©´ BeatSyncë¥¼ í†µí•´ ë°©ì— ëŒ€í•œ ì •ë³´ ë° ë²„ì „ì„ ì—…ë°ì´íŠ¸í•©ë‹ˆë‹¤.</p>
                            <p>2. í•´ë‹¹ ì´ë²¤íŠ¸ë¥¼ MsgQueue Pipeì— ë°œí–‰í•©ë‹ˆë‹¤.</p>
                            <p>3. PipeëŠ” PipeChainìœ¼ë¡œ ë¶€í„° ì§„ì… ì‹œ í•„í„°ë¥¼ ê±°ì¹˜ê³  ë°œí–‰ ì‹œ íŠ¹ì • ë¡œì§ì„ ì²˜ë¦¬í•˜ë©°,</p>
                            <p>4. ì²˜ë¦¬ ê²°ê³¼ê°€ ì‹œê·¸ë„ë§ ì„œë²„ë¡œ ì „ì†¡ë©ë‹ˆë‹¤.</p>
                        </div>
                        <div class="gram">
                            flowchart LR
                            A[Server] -->|"Event
                            SSE Stream"| B[Client]
                            B[Client] --> |"BeatSync
                            RoomInfo Version"| C["Pipe (MSG Queue)"]
                            C["Pipe (MSG Queue)"]
                            
                            D[Pipe] --> |Filter| E[PipeChain]
                            E[PipeChain] --> |Consume|F[EventRequest]
                            F[EventRequest] --> |HttpRequest| G[Server]
                            
                        </div>

                        <h3>í´ë˜ìŠ¤ êµ¬ì¡°</h3>
                        <div class="gram">
                        classDiagram
                        class RTCClient {
                            +Room room;
                            +CamClient camClient;
                            +ClientSyncer clientSyncer;
                            +Pipe pipe;
                            +RTCManager rtcManager;
                            +createRoom()
                            +joinRoom(uuid)
                        }

                        class ClientSyncer {
                            +EventSource sseEvent
                            +SyncBoard syncBoard;
                            +SyncChat syncChat;
                            +sseBind()
                            +beatSync(handleEvent, rsRoom)
                        }

                        class Pipe{
                            +PipeChain pipeChain
                            +enqueue(data)
                            +dequeue()
                            +publish(type)
                        }

                        class RTCManager {
                            +Map rtcStore
                            +spawnCaller(data)
                            +spawReceiver(data)
                            +connect(data)
                        }

                        class PipeChain {
                            +Funtions rtcStableCallbacks
                            +enqueueFilter(pipeItems, data)
                            +rtcStableFilter(type, cb)
                            +rtcStableSend(type, data)
                        }

                        RTCClient  --> ClientSyncer : references
                        RTCClient  --> Pipe : references
                        RTCClient  --> RTCManager : references
                        Pipe --> PipeChain : references
                        ClientSyncer --> SyncBoard : references
                        ClientSyncer --> SyncChat : references
                        </div>

                        <h2>ClientSyncer</h2>
                        <div class="blockquote">
                            <p>ì„œë²„ì™€ ì´ë²¤íŠ¸ë¥¼ ì†¡ìˆ˜ì‹ í•˜ì—¬ í´ë¼ì´ì–¸íŠ¸ë“¤ê³¼ ë™ê¸°í™”ë¥¼ ì²˜ë¦¬í•˜ëŠ” í´ë˜ìŠ¤ì…ë‹ˆë‹¤.
                                <br>ë˜í•œ Web RTCê°€ ì—°ê²°ë˜ì–´ P2Pìƒíƒœì— ëŒì… ë˜ì—ˆì„ ë•Œì—ë„ DataChanellì„ í†µí•´ ë™ê¸°ì„±ì„ ì²˜ë¦¬í•©ë‹ˆë‹¤.
                            </p>
                        </div>

                        <h3>sseBind</h3>
                        <div class="post-root">
                            <article class="post-content">
                                <div class="folded-corner">
                                    <p>Event Stream ì½œë°± ë° DataChanell ì½œë°±ì„ ì„¤ì • í•©ë‹ˆë‹¤.
                                        <br>EventëŠ” ë¹„íŠ¸ ì‹±í¬ë¡œ í–¥í•˜ë©°,
                                        <br>P2P DataChanell Msg SyncBoard ë° SyncChatì´ ì‚¬ìš©í•©ë‹ˆë‹¤. 
                                    </p>
                                </div>
                                <pre class="prettyprint">
                                    <br>
            sseBind(rs){
                .
                .
                .

                this._eventSource = new EventSource(path);
                this._eventSource.onmessage = (e) =>{
                    const roomStateEventHandler = JSON.parse(e.data);
                    this.heartbeatSyncStatus(roomStateEventHandler.handleEvent, roomStateEventHandler.room);
                }
        
                this._rtcManager.msgReceiver = (event) =>{
                    const receivedBuffer = event.data;
                    const receivedString = new TextDecoder().decode(receivedBuffer);
                    const receivedObj = JSON.parse(receivedString);
                    this._SyncBoard.receive(receivedObj);
                    this._SyncChat.receive(receivedObj);
                }

            }
                                </pre>
                            </article>
                        </div>

                        <h3>heartbeatSyncStatus</h3>
                        <div class="post-root">
                            <article class="post-content">
                                <div class="folded-corner">
                                    <p>ì„œë²„ì˜ ë£¸ ì •ë³´ ë° ì´ë²¤íŠ¸ì— ì˜ê±° ì í•©í•œ ì´ë²¤íŠ¸ë¥¼ Pipeë¡œ ë°œí–‰í•©ë‹ˆë‹¤.</p>
                                </div>
                                <pre class="prettyprint">
                                    <br>
            heartbeatSyncStatus(handleEvent, rsRoom){
                .
                .
                .
                if(room.lastModified < rsRoom.lastModified){
        
                    if(eventType === "join"){
                        this.syncJoin(rsRoom);
                    }
        
                    this._rtcClient.updateBeatSync(rsRoom);
                }
                else if(room.lastModified === rsRoom.lastModified){
                    if(eventType === "offer"){
                        this.syncHandleOffer(handleEvent)
                    }
        
                    if(eventType === "answer"){
                        this.syncHandleAnswer(handleEvent)
                    }
                }
        
            }
                                </pre>   
                                <pre class="prettyprint">
                                    <br>
            syncJoin(rsRoom){
                .
                .
                for(let it of Object.values(rsRoom.camClients)){
                    const target = it;
                    if(camIndex < target.index){
                        const data = { type : "offer", target : target.clientUuid, sdp : ""};
                        pipe.enqueue(data);
                    }
                }
                pipe.publish("offer");
            }
                                </pre>     
                            </article>
                        </div>

                        <h2>RTCClient</h2>
                        <div class="blockquote">
                            <p>RTC Clientì˜ ì§„ì…ì  ë° ì—¬ëŸ¬ ê°ì²´ë¥¼ ê´€ë¦¬í•˜ëŠ” í´ë˜ìŠ¤ì…ë‹ˆë‹¤.
                                <br>íŒŒì´í”„ë¼ì¸ì„ ì •ì˜í•˜ê¸°ë„ í•©ë‹ˆë‹¤.
                            </p>
                        </div>

                        <h3>preCreatePipeLine</h3>
                        <div class="post-root">
                            <article class="post-content">
                                <div class="folded-corner">
                                    <p>RTC Managerì— ë°œì‹ ì í˜¹ì€ ìˆ˜ì‹ ìë¥¼ ìš”ì²­í•˜ê±°ë‚˜,
                                        <br>ì´ë²¤íŠ¸ íŒŒì´í”„ ë¼ì¸ì„ íŒŒì´í”„ ì²´ì¸ìœ¼ë¡œë¶€í„° êµ¬ì¶•í•©ë‹ˆë‹¤.
                                        <br>í•„í„°ë¥¼ í†µí•´ ì§„ì… ì—¬ë¶€ ì½œë°± ì •ì˜í•˜ê±°ë‚˜,
                                        <br>ë°œí–‰ì‹œ ì²˜ë¦¬í•´ì•¼ í•  ë¡œì§ì„ ì •ì˜í•˜ê³  ì„œë²„ë¡œ ì´ë²¤íŠ¸ë¥¼ ë°œí–‰í•©ë‹ˆë‹¤.
                                    </p>
                                </div>
                                <pre class="prettyprint">
                                    <br>
            async preCreatePipeLine(){
                .
                .
                pipeChain.setRtcStableFilter("offer", (data)=>{
                    return !this._rtcManager.hasRtc(data);
                });
        
                pipeChain.setRtcStableSend("offer", async (data)=>{
                    const rtcCaller = await this._rtcManager.spawnCaller(data);
                    .
                    .
                    .
                    const handleEvent = new HandleEvent()
                        .spawn("offer", roomUuid, clientUuid, targetUuid, offer);
        
                    const eventType = "offer";
                    this._server.hanlder( handleEvent );
                });
            }
                                </pre>
                            </article>
                        </div>

                        <h2>RTCManager</h2>
                        <div class="blockquote">
                            <p>EventStream ë° Pipeë¡œ ë¶€í„° ë°œí–‰ë˜ëŠ” ì½œë°±ìœ¼ë¡œ ì¸í•œ ìƒíƒœ ë³€í™”ì—,
                                <br>RTC ê°ì²´ ìƒíƒœë¥¼ ì „í™˜ì‹œí‚¤ë©° RTC Connect Flowë¥¼ ì»¨íŠ¸ë¡¤ í•˜ëŠ” í´ë˜ìŠ¤ì…ë‹ˆë‹¤.  
                            </p>
                        </div>

                        <h3>spawnCaller</h3>
                        <div class="post-root">
                            <article class="post-content">
                                <div class="folded-corner">
                                    <p>ë°œì‹ ìë¥¼ ìƒì„±í•©ë‹ˆë‹¤. ìƒíƒœë¥¼ ì†Œìœ í•˜ê³  ìˆëŠ” RTC ê°ì²´ë¥¼ í• ë‹¹í•˜ë©°,
                                        <br>WebRTC P2P DataChannel, í˜¹ì€ WebRTC ì½œë°± ë“±ì„ ì •ì˜í•©ë‹ˆë‹¤.
                                        <br>SDP ì¸ì¦ì„œ ë° Video Elementë¥¼ ê´€ë¦¬í•©ë‹ˆë‹¤.
                                    </p>
                                </div>
                                <pre class="prettyprint">
                                    <br>

            async spawnCaller(data){
                .
                .
                if(!hasKey){
                    const rtc = new RTC(target);
                    typeMap.set(target, rtc);
        
                    const result = await rtc.changeStatus( RTC.status.spawnCaller, async ()=>{
                        rtc.pc = new RTCPeerConnection();
                        rtc.dc = rtc.pc.createDataChannel("channel");
                        rtc.dc.onopen = (event) => {
                            this._connector(event);
                        };

                        rtc.dc.onmessage = (event) => {
                            this._msgReceiver(event);
                        };

                        const iceSdpPromise = new Promise(resolve => {
                            rtc.pc.onicecandidate = (event) => {
                                if (rtc.pc && rtc.pc.localDescription) {
                                    rtc.iceSDP = JSON.stringify(rtc.pc.localDescription);
                                    resolve(rtc.iceSDP);
                                }
                            };
                        });
        
                        rtc.pc.ontrack = ( event ) => {
                            rtc.spawnRemoteVideo(event);
                        }
        
                        const offer = await rtc.pc.createOffer();
                        await rtc.pc.setLocalDescription(offer);
                        await iceSdpPromise;
                        return typeMap.get(target);
                    });
        
                    return result;
                }
        
                return typeMap.get(target);
            }
                                </pre>
                            </article>
                        </div>

                        <h2>SyncBoard</h2>
                        <div class="blockquote">
                            <p>DataChanellì„ í†µí•´ ì‚¬ìš©ìë“¤ì˜ ì†¡ìˆ˜ì‹ ëœ ë°ì´í„°ë¥¼ ê¸°ë°˜ ë³´ë“œë¥¼ ë™ê¸°í™”í•©ë‹ˆë‹¤.
                                <br>ë©”ì¸ ìº”ë²„ìŠ¤ ë’¤ì— ë²„í¼ ìº”ë²„ìŠ¤ë¥¼ ë‘ ê°œë¥¼ ì¶”ê°€ë¡œ ë°°ì¹˜í•˜ì—¬,
                                <br>ë°˜ì‘ì„± ë° ê°ì²´ ê´€ë¦¬ë¥¼ í–¥ìƒì‹œì¼°ìŠµë‹ˆë‹¤.
                            </p>
                        </div>

                        <h3>receive</h3>
                        <div class="post-root">
                            <article class="post-content">
                                <div class="folded-corner">
                                    <p>ìˆ˜ì‹ ë°›ì€ ë©”íƒ€ ë°ì´í„°ë¥¼ í™•ì¸í•˜ì—¬ ë³´ë“œë¥¼ ì§€ìš°ê±°ë‚˜,
                                        <br>ë¼ì¸ ë° ì»¤ì„œ ë° ì´ë¯¸ì§€ë¥¼ ê·¸ë ¤ëƒ…ë‹ˆë‹¤.
                                    </p>
                                </div>
                                <pre class="prettyprint">
                                    <br>

                receive(data){
                    const { owner, msg, type} = data;
            
                    if(type === "board"){
                        const drawData = JSON.parse(msg);
                        this.drawing(owner, drawData.style, drawData.x, drawData.y);
                    }
                    else if(type === "board-img"){
                        const imgData = JSON.parse(msg);
                        const img = new Image();
                        img.src = imgData.basebuffer;
                        img.onload = ()=>{
                            const {x, y, sizeX, sizeY } = imgData.imgstyle;
                            this._bfCtx.drawImage(img, x, y, sizeX, sizeY);
                            this._bfCtx.drawImage(this._lineCanvas, 0, 0);
                            this._ctx.drawImage(this._bufferCanvas, 0, 0);
                        }   
                    }
                    else if(type === "board-system"){
                        if(msg === "eraser"){
                            this.eraser();
                        }
                    }
                }
                                </pre>
                            </article>
                        </div>

<!-- WebRTC Client END-->
                    </div>
                </div>
                <div class="bottom">
                    <div class="flush-btn">
                        <p>í”„ë¡œì íŠ¸</p>
                    </div>
                </div>
            </div>
        </div>
    </div>
</body>
</html>